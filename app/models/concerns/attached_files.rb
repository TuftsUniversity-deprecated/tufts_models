require 'open3'

module AttachedFiles
  extend ActiveSupport::Concern

  included do
    class_attribute :default_datastream
    attr_accessor :content_will_update
  end

  def create_derivatives
  end

  def local_path_for(name, extension=nil)
    LocalPathService.new(self, name, extension).local_path
  end

  def encode_mp3(input_file, output_path)
    opts = ""
    if File.extname(input_file) == '.mp3'
      # Don't re-encode, just copy
      FileUtils.cp(input_file, output_path)
    else
      self.class.encode(input_file, output_path) #'mp3', 'audio/mp3', opts)
    end
  end

  # Given a datastream name, return the local path where the file can be found.
  # If an extension is provided, generate the path, if the extension is not provided,
  # derive it from the stored dsLocation
  # @example
  #   obj.file_path('Archival.tif', 'tif')
  #   # => /local_object_store/data01/tufts/central/dca/MS054/archival_tif/MS054.003.DO.02108.archival.tif
  def file_path(name, extension=nil)
    File.join(directory_for(name), "#{PidUtils.stripped_pid(pid)}.#{name.downcase}")
  end
  # Given a datastream name, return the directory path where the file can be found.
  # @example
  #   # Given that pid is tufts:MS054.001.002
  #   obj.file_path('Archival.tif')
  #   # => /local_object_store/data01/tufts/central/dca/MS054/archival_tif
  #   # Given that pid is tufts:123
  #   obj.file_path('Archival.tif')
  #   # => /local_object_store/data01/tufts/sas/archival_tif
  def directory_for(name)
    name = 'thumb.png' if name.downcase.eql? 'thumbnail.png'

    if PidUtils.autogenerated?(pid)
      name.downcase.gsub('.', '_')
    else
      File.join(collection_code, name.downcase.gsub('.', '_'))
    end
  end

  private

  def collection_code
    if collection_id
      collection_id.sub(/.+\.([^.]+)$/, '\1')
    else
      pid.sub(/.+:([^.]+).*/, '\1')
    end
  end


# 2. There are two locations where uploaded files and manifestations end up. We will refer to them as "Tisch" and "DCA".
#   a. You can figure out which is which based on the PID creation
#     i.  If the objects use an automatically created pid, then they are "Tisch" objects.
#     ii. If the objects use a user-supplied PID, then they are "DCA" objects.
#   c. The location of the uploaded file is determined by the object type. The path is NFS mounted on the same system where the server is running, beginning at the location Mike refers to in his e-mail as "bucket".
#     i.      If this is a "Tisch" object then it goes in [bucket]/tufts/sas, and then the appropriate directory as in 2b. above.
#     ii.      If this is a "DCA" object than it goes in [bucket]/tufts/central/dca/[collection #], and then the appropriate directory as in 2b. above.
#         1. "Collection #" is a five digit alphanumeric string (e.g. "MS001"). These five characters are the first five characters in the PID after "tufts:".
#         2. For example, for the PDF with the PID tufts:UA015.012.079.00001, the PDF datastream would go into a directory called [bucket]/tufts/central/dca/UA015/archival_pdf



  module ClassMethods

    # @note this overrides the has_file_datastream method from ActiveFedora::Base
    #   Adding the :default option.
    # @overload has_file_datastream(name, args)
    #   Declares a file datastream exists for objects of this type
    #   @param [String] name
    #   @param [Hash] args
    #     @option args :type (ActiveFedora::Datastream) The class the datastream should have
    #     @option args :label ("File Datastream") The default value to put in the dsLabel field
    #     @option args :control_group ("M") The type of controlGroup to store the datastream as. Defaults to M
    #     @option args :default [Boolean] used to indicate this is the datastream to attach an uploaded file to if the user hasn't provided the DSID
    #     @option args [Boolean] :autocreate Always create this datastream on new objects
    #     @option args [Boolean] :versionable Should versioned datastreams be stored
    # @overload has_file_datastream(args)
    #   Declares a file datastream exists for objects of this type
    #   @param [Hash] args
    #     @option args :name ("content") The dsid of the datastream
    #     @option args :type (ActiveFedora::Datastream) The class the datastream should have
    #     @option args :label ("File Datastream") The default value to put in the dsLabel field
    #     @option args :control_group ("M") The type of controlGroup to store the datastream as. Defaults to M
    #     @option args :default [Boolean] used to indicate this is the datastream to attach an uploaded file to if the user hasn't provided the DSID
    #     @option args [Boolean] :autocreate Always create this datastream on new objects
    #     @option args [Boolean] :versionable Should versioned datastreams be stored
    def has_file_datastream(*args)
      super
      if args.first.is_a? String
        name = args.first
        args = args[1] || {}
        args[:name] = name
      else
        args = args.first || {}
      end

      self.default_datastream = args.fetch(:name, 'content') if args[:default]
    end

    def encode(input_file, output_file)
      options = '-b:a 192k'
      command = "#{ffmpeg_path} -y -i \"#{input_file}\" #{options} #{output_file}"
      stdin, stdout, stderr, wait_thr = Open3.popen3(command)
      stdin.close
      out = stdout.read
      stdout.close
      err = stderr.read
      stderr.close
      raise "Unable to execute command \"#{command}\"\n#{err}" unless wait_thr.value.success?
    end

    def ffmpeg_path
      'ffmpeg'
    end
  end
end
